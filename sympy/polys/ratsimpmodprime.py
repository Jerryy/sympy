from groebnertools import *
from sympy import symbols, solve

def sdp_total_degree(f):
    d = 0
    for term in f:
        if d < sum(term[0]):
            d = sum(term[0])
    return d

def tuple_incr(t, i):
    r = list(t)
    r[i] += 1
    return r

def monomials(G, n, u, O):
    """
    adapted from http://www-salsa.lip6.fr/~jcf/Papers/2010_MPRI5e.pdf
    """
    L = [(0,) * (u + 1)]
    i = 0

    while i < len(L):
        t = L[i]
        L.extend([tuple_incr(t, i) for i in xrange(u + 1) if sum(tuple_incr(t, i)) <= n])
        L.sort(key=lambda m: O(m))
        i += 1

    return L



def ratsimp_mod_prime(a, b, G, u, O, K, N=0, D=0):
    """
    Find rational simplification of a/b mod the prime ideal generated by G.
    """
    c, d = a, b
    steps = 0

    while N + D < sdp_total_degree(a) + sdp_total_degree(b):
        M1 = monomials(G, N, u, O)
        M2 = monomials(G, D, u, O)

        C = symbols("c:%d" % len(M1))
        D = symbols("d:%d" % len(M2))

        c_hat = [(M1[i], C[i]) for i in xrange(len(M1))]
        d_hat = [(M2[i], D[i]) for i in xrange(len(M2))]

        # for safety:
        sdp_sort(c_hat, O)
        sdp_sort(d_hat, O)

        r = sdp_sub(sdp_mul(a, d_hat, u, O, K), sdp_mul(b, c_hat, u, O, K), u, O, K)
        r = sdp_rem(r, G, u, O, K)

        # coefficients:
        S = [term[1] for term in r]

        # solve system S
        Sol = solve(S, C+D)
        if Sol is not None:
            # works with expr...
            c = c_hat.subs(Sol)
            d = d_hat.subs(Sol)
            break
        
        N += 1
        D += 1
        steps += 1

    if steps > 0:
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N, D - steps)
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N - steps, D)

    return c, d
