from groebnertools import *
from sympy import symbols, solve

"""
def ratsimp_mod_prime(a, b, G, u, O, K, N=0, D=0):
    ""
    Find rational simplification of a/b mod the prime ideal generated by G.
    ""
    c, d = a, b
    steps = 0

    while N + D < sdp_total_degree(a) + sdp_total_degree(b):
        M1 = monomials(G, N, u, O)
        M2 = monomials(G, D, u, O)

        C = symbols("c:%d" % len(M1))
        D = symbols("d:%d" % len(M2))

        c_hat = [(M1[i], C[i]) for i in xrange(len(M1))]
        d_hat = [(M2[i], D[i]) for i in xrange(len(M2))]

        # for safety:
        sdp_sort(c_hat, O)
        sdp_sort(d_hat, O)

        r = sdp_sub(sdp_mul(a, d_hat, u, O, K), sdp_mul(b, c_hat, u, O, K), u, O, K)
        r = sdp_rem(r, G, u, O, K)

        # coefficients:
        S = [term[1] for term in r]

        # solve system S
        Sol = solve(S, C+D)
        if Sol is not None:
            # works with expr...
            c = c_hat.subs(Sol)
            d = d_hat.subs(Sol)
            break
        
        N += 1
        D += 1
        steps += 1

    if steps > 0:
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N, D - steps)
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N - steps, D)

    return c, d
"""

def _normalform(f, G, gens, opt):
    

    polys = []

    for poly in [f] + G:
        polys.append(sdp_from_dict(poly.rep.to_dict(), monomial_key(opt.order)))

    r = sdp_rem(polys[0], polys[1:], len(gens) - 1, monomial_key(opt.order), opt.domain)
    r = Poly._from_dict(dict(r), opt)
   
    return r
            
def ratsimp_mod_prime(a, b, G, opt, N=0, D=0):
    c, d = a, b
    steps = 0

    while N + D < a.total_degree() + b.total_degree():
        #M1 = monomials(G, N, order)
        #M2 = monomials(G, D, order)
        M1 = [Poly(m) for m in monomials(list(f.free_symbols)) if monomial_div(Poly(m).LM()...

        C = symbols("c:%d" % len(M1))
        D = symbols("d:%d" % len(M2))

        c_hat = sum([C[i] * M1[i] for i in xrange(len(M1))])
        d_hat = sum([D[i] * M2[i] for i in xrange(len(M2))])

        r = normalform(a * d_hat - b * c_hat, G, order)

        S = r.coeffs()

        sol = solve(S, C + D)

        if sol is not None:
            c = c_hat.subs(sol)
            d = d_hat.subs(sol)
            break

        N += 1
        D += 1
        steps += 1

    if steps > 0:
        c, d = ratsimp_mod_prime(c, d, G, order, N, D - steps)
        c, d = ratsimp_mod_prime(c, d, G, order, N - steps, D)

    return c, d
