from groebnertools import *
from sympy import symbols, solve

"""
def sdp_total_degree(f):
    d = 0
    for term in f:
        if d < sum(term[0]):
            d = sum(term[0])
    return d

def tuple_incr(t, i):
    r = list(t)
    r[i] += 1
    return r

def monomials(G, n, u, O):
    ""
    adapted from http://www-salsa.lip6.fr/~jcf/Papers/2010_MPRI5e.pdf
    ""
    L = [(0,) * (u + 1)]
    i = 0

    while i < len(L):
        t = L[i]
        L.extend([tuple_incr(t, i) for i in xrange(u + 1) if sum(tuple_incr(t, i)) <= n])
        L.sort(key=lambda m: O(m))
        i += 1

    return L



def ratsimp_mod_prime(a, b, G, u, O, K, N=0, D=0):
    ""
    Find rational simplification of a/b mod the prime ideal generated by G.
    ""
    c, d = a, b
    steps = 0

    while N + D < sdp_total_degree(a) + sdp_total_degree(b):
        M1 = monomials(G, N, u, O)
        M2 = monomials(G, D, u, O)

        C = symbols("c:%d" % len(M1))
        D = symbols("d:%d" % len(M2))

        c_hat = [(M1[i], C[i]) for i in xrange(len(M1))]
        d_hat = [(M2[i], D[i]) for i in xrange(len(M2))]

        # for safety:
        sdp_sort(c_hat, O)
        sdp_sort(d_hat, O)

        r = sdp_sub(sdp_mul(a, d_hat, u, O, K), sdp_mul(b, c_hat, u, O, K), u, O, K)
        r = sdp_rem(r, G, u, O, K)

        # coefficients:
        S = [term[1] for term in r]

        # solve system S
        Sol = solve(S, C+D)
        if Sol is not None:
            # works with expr...
            c = c_hat.subs(Sol)
            d = d_hat.subs(Sol)
            break
        
        N += 1
        D += 1
        steps += 1

    if steps > 0:
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N, D - steps)
        c, d = ratsimp_mod_prime(c, d, G, u, O, K, N - steps, D)

    return c, d
"""

#def monomials(G, n, order):
#    M = []
#    for g in G:
#        M.append(g.LM(order))

def normalform(p, G, order):
    """
    Compute (complete) normal form of p w.r.t. G.
    """
    while True: # doesn't work
        for i, g in enumerate(G):
            if monomial_div(p.LM(order), g.LM(order)) is not None:
                p = p.rem(g) # this might be wrong... instead of a single reduction with g, a full one is done here
                break
        else:
            break
    return p
            
def ratsimp_mod_prime(a, b, G, order='lex', N=0, D=0):
    c, d = a, b
    steps = 0

    while N + D < a.total_degree() + b.total_degree():
        #M1 = monomials(G, N, order)
        #M2 = monomials(G, D, order)
        M1 = [Poly(m) for m in monomials(list(f.free_symbols)) if monomial_div(Poly(m).LM()...

        C = symbols("c:%d" % len(M1))
        D = symbols("d:%d" % len(M2))

        c_hat = sum([C[i] * M1[i] for i in xrange(len(M1))])
        d_hat = sum([D[i] * M2[i] for i in xrange(len(M2))])

        r = normalform(a * d_hat - b * c_hat, G, order)

        S = r.coeffs(order) # works if r is a polynomial

        sol = solve(S, C + D)

        if sol is not None:
            c = c_hat.subs(sol)
            d = d_hat.subs(sol)
            break

        N += 1
        D += 1
        steps += 1

    if steps > 0:
        c, d = ratsimp_mod_prime(c, d, G, order, N, D - steps)
        c, d = ratsimp_mod_prime(c, d, G, order, N - steps, D)

    return c, d
