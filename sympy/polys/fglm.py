"""Convert Groebner bases of zero-dimensional ideals from one monomial order to another. """

from sympy.polys.polytools import options, parallel_poly_from_expr, Poly
from sympy.polys.groebnertools import sdp_from_dict, sdp_rem, sdp_sort
from sympy.polys.monomialtools import monomial_key, monomial_div
from sympy.utilities import flatten
from sympy import symbols, solve

def is_zero_dimensional(G, *gens, **args):
    """
    Checks if the ideal generated by G is zero-dimensional (or,
    equivalently, if the number of solutions of the system G is
    finite).
    In order to always obtain a correct result, G has to be a
    Groebner basis. However, if G is not a Groebner basis and `True`
    is returned, the ideal is zero-dimensional.

    For an ideal to be zero-dimensional, for every variable some
    power has to be the leading monomial of an element of G.

    >>> from sympy import symbols
    >>> from sympy.polys.fglm import is_zero_dimensional
    >>> from sympy.polys import groebner
    >>> x, y, z = symbols('x, y, z')
    >>> F = [x**3 + x + 1, y**2 + 1, z - (x**2 + y)]
    >>> is_zero_dimensional(F, z, x, y, order='lex')  # lucky choice!
    True
    >>> is_zero_dimensional(F, x, y, z, order='lex')
    False
    >>> G = groebner(F, x, y, z, order='grlex')
    >>> is_zero_dimensional(G, x, y, z, order='grlex')
    True

    **References**
    Ideals, Varieties and Algorithms, David A. Cox, John B. Little, Donal O'Shea, 3rd edition, p. 234
    """
    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(G, *gens, **args)
    except PolificationError, exc:
        raise ComputationFailed('is_zero_dimensional', len(G), exc)

    u = len(flatten(gens)) - 1

    def single_var(m):
        """Returns `True` if only a single entry of the tuple m is not `0`. """
        n = 0
        for v in m:
            if v != 0:
                n += 1
        return n == 1

    # select leading monomials that are powers of a single variable
    leading_monomials = [g.LM(opt.order) for g in polys if single_var(g.LM(opt.order)) == True]

    exponents = [0] * (u + 1)

    for m in leading_monomials:
        exponents = map(lambda (e, f): e + f, zip(exponents, m))

    product = 1
    for e in exponents:
        product *= e

    return product != 0  #, product

def normalform(f, G, order, gens):
    """
    Computes the complete reduction of ``f`` modulo ``G``
    w.r.t. ``order``.
    """
    def term((m, c)):
        r = 1 
        for i, v in enumerate(gens):
            r *= v**m[i]
        return c * r

    r = Poly(0, f.gens)
    while not f.is_zero:
        for g in G:
            if monomial_div(f.LM(order), g.LM(order)) is not None:
                ltf = term(f.LT(order))
                ltg = term(g.LT(order))
                f = f - Poly(ltf/ltg, f.gens) * g
                break
        else:
            ltf = f.as_expr().as_ordered_terms(order)[0]
            r = r + Poly(ltf, f.gens)
            f = f - Poly(ltf, f.gens)
    return r

def fglm(F, to_order, *gens, **args):
    """
    FGLM
    """
    #if is_zero_dimensional(F, *gens, **args) == False:
    #    raise ComputationFailed("Ideal generated by G not zero-dimensional")

    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(F, *gens, **args)
    except PolificationFailed, exc:
        raise ComputationFailed('fglm', len(F), exc)

    domain = opt.domain

    if domain.has_assoc_Field:
        opt.domain = domain.get_field()
    else:
        raise DomainError("can't convert Groebner basis over %s" % domain)

    for i, p in enumerate(polys):
        polys[i] = p.set_domain(opt.domain)

    gens = flatten(gens)

    L = []
    S = []
    V = []
    G = []
    t = Poly(1, gens)

    while True:
        #v = _normalform(t, polys, gens, opt)
        v = normalform(t, polys, opt.order, opt.gens)
        
        _lambda = symbols("l:%d" % len(V))
        p = v - sum([Poly(_lambda[i], gens) * V[i] for i in xrange(len(V))])
        
        coeffs = p.coeffs()
        
        if coeffs == [1]:
            sol = None
        else:
            sol = solve(coeffs, _lambda)
        
        if sol:
            p = t - sum([Poly(_lambda[i], gens) * S[i] for i in xrange(len(V))])
            if len(_lambda) == 1:
                p = p.subs(_lambda[0], sol[0])
            else:
                p = p.subs(sol)
                p = p.subs(dict(zip(_lambda, [0] * len(_lambda))))  # remove remaining variables
            G.append(Poly(p, gens))
        else:
            S.append(t)
            V.append(v)

            L.extend([t * Poly(var, gens) for var in gens])

            indices = []
            for i, l in enumerate(L):
                if any([monomial_div(l.LM(to_order), g.LM(to_order)) is not None for g in G]):
                    indices.append(i)
            for i in reversed(indices):
                del L[i]

            L.sort(key=lambda f: monomial_key(to_order)(f.LM(to_order))) # from, to?

        if L == []:
            if not domain.has_Field:
                G = [ g.clear_denoms(convert=True)[1] for g in G ]

            opt.order = to_order
            R = reduced(G, gens, opt)
            R.sort(key=lambda f: monomial_key(to_order)(f.LM(to_order)), reverse=True)
            if not opt.polys:
                return [g.as_expr() for g in R]
            else:
                return R

        t = L[0]
        del L[0]

def reduced(G, gens, opt):
    F = G
    H = []

    while F:
        f0 = F.pop()

        if not any([monomial_div(f0.LM(opt.order), f.LM(opt.order)) is not None for f in F + H]):
            H.append(f0)

    R = []

    for i, g in enumerate(H):
        g = normalform(g, H[:i] + H[i + 1:], opt.order, opt.gens)
        if not g.is_zero:
            R.append(g)

    return R
