"""Conversion of Groebner basis of zero-dimensional ideals. """

from sympy.polys.polytools import options, parallel_poly_from_expr, Poly
from sympy.polys.polyerrors import ComputationFailed, PolificationFailed
from sympy.polys.monomialtools import monomial_key, monomial_div
from sympy.utilities import flatten
from sympy import symbols, solve, reduced, QQ

def is_zero_dimensional(G, *gens, **args):
    """
    Checks if the ideal generated by G is zero-dimensional (or,
    equivalently, if the number of solutions of the system G is
    finite).
    In order to always obtain a correct result, G has to be a
    Groebner basis. However, if G is not a Groebner basis and `True`
    is returned, the ideal is zero-dimensional.

    For an ideal to be zero-dimensional, for every variable some
    power has to be the leading monomial of an element of G.

    >>> from sympy import symbols
    >>> from sympy.polys.fglm import is_zero_dimensional
    >>> from sympy.polys import groebner
    >>> x, y, z = symbols('x, y, z')
    >>> F = [x**3 + x + 1, y**2 + 1, z - (x**2 + y)]
    >>> is_zero_dimensional(F, z, x, y, order='lex')  # lucky choice!
    True
    >>> is_zero_dimensional(F, x, y, z, order='lex')
    False
    >>> G = groebner(F, x, y, z, order='grlex')
    >>> is_zero_dimensional(G, x, y, z, order='grlex')
    True

    **References**
    Ideals, Varieties and Algorithms, David A. Cox, John B. Little, Donal O'Shea, 3rd edition, p. 234
    """
    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(G, *gens, **args)
    except PolificationError, exc:
        raise ComputationFailed('is_zero_dimensional', len(G), exc)

    u = len(flatten(gens)) - 1

    def single_var(m):
        """Returns `True` if only a single entry of the tuple m is not `0`. """
        n = 0
        for v in m:
            if v != 0:
                n += 1
        return n == 1

    leading_monomials = [g.LM(opt.order) for g in polys if single_var(g.LM(opt.order)) == True]

    exponents = [0] * (u + 1)

    for m in leading_monomials:
        exponents = map(lambda (e, f): e + f, zip(exponents, m))

    product = 1
    for e in exponents:
        product *= e

    return product != 0  #, product


def reduced_basis(G, gens, order):
    F = G
    H = []

    while F:
        f0 = F.pop()

        if not any([monomial_div(f0.LM(order), f.LM(order)) is not None for f in F + H]):
            H.append(f0)

    R = []

    for i, g in enumerate(H):
        g = reduced(g.as_expr(), H[:i] + H[i + 1:], gens, order=order, polys=True)[1]
        if not g.is_zero:
            R.append(g)

    return sorted(R, key=lambda f: monomial_key(order)(f.LM(order)), reverse=True)


def _fglm(F, gens, opt, to_order):
    """
    FGLM
    """
    L = []
    S = []
    V = []
    G = []
    t = Poly(1, gens)

    while True:
        v = reduced(t.as_expr(), F, opt.gens, order=opt.order, domain=opt.domain, polys=True)[1]

        _lambda = symbols("l:%d" % len(V))
        p = v - sum([Poly(_lambda[i], gens) * V[i] for i in xrange(len(V))])

        coeffs = p.coeffs()

        # avoid "GeneratorsNeeded: specify generators to give 1 a meaning":
        if coeffs == [1]:
            sol = None
        else:
            sol = solve(coeffs, _lambda)

        if sol:
            for key in sol.keys():
                sol[key] = sol[key].subs(dict(zip(_lambda, [0] * len(_lambda))))

            p = t - sum([Poly(_lambda[i], gens) * S[i] for i in xrange(len(V))])
            if len(_lambda) == 1:
                p = p.subs(_lambda[0], sol[0])
            else:
                p = p.subs(sol)

            # Remove remaining free variables
            p = Poly(p.subs(dict(zip(_lambda, [0] * len(_lambda)))), gens)

            # Poly(0, gens).LM() == (0, ..., 0) which divides all monomials and
            # would cause the algorithm to stop prematurely.
            if not p.is_zero:
                G.append(Poly(p, gens))
        else:
            S.append(t)
            V.append(v)

            L.extend([t * Poly(var, gens) for var in gens])

            L = [l for l in L if all([monomial_div(l.LM(to_order), g.LM(to_order)) is None for g in G])]

            L.sort(key=lambda f: monomial_key(to_order)(f.LM(to_order)), reverse=True)

        if L == []:
            return reduced_basis(G, gens, to_order)

        t = L.pop()

def fglm(F, to_order, *gens, **args):
    """
    Convert Groebner basis ``F`` of zero-dimensional ideal w.r.t.
    ``order`` option to Groebner basis w.r.t. ``to_order`` (this will
    be more convenient).

    Example
    =======

    >>> from sympy.polys.fglm import fglm
    >>> from sympy.abc import x, y, z
    >>> from sympy import groebner
    >>> F = [x**3+x+1, y**2+1, z - (x**2 + y)]
    >>> G = groebner(F, x,y,z,order='grevlex')
    >>> fglm(G, 'lex', x, y, z, order='grevlex')
    [69*x + 28*z**5 + 67*z**4 + 132*z**3 + 58*z**2 + 116*z + 189, 69*y - 26*z**5 - 77*z**4 - 162*z**3 - 113*z**2 - 157*z - 210, z**6 + 4*z**5 + 9*z**4 + 10*z**3 + 8*z**2 + 12*z + 9]
    """
    if not is_zero_dimensional(F, *gens, **args):
        raise ComputationFailed("Ideal generated by G not zero-dimensional")

    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(F, *gens, **args)
    except PolificationFailed, exc:
        raise ComputationFailed('fglm', len(F), exc)

    domain = opt.domain

    if domain.has_assoc_Field:
        opt.domain = domain.get_field()
    else:
        raise DomainError("can't convert Groebner basis over %s" % domain)

    for i, p in enumerate(polys):
        polys[i] = p.set_domain(opt.domain)

    gens = flatten(gens)

    G = _fglm(polys, gens, opt, to_order)

    if not domain.has_Field:
        G = [g.clear_denoms(convert=True)[1] for g in G]

    if not opt.polys:
        return [g.as_expr() for g in G]
    else:
        return G


