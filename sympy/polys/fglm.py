"""Convert Groebner bases of zero-dimensional ideals from one monomial order to another. """

from sympy.polys.polytools import options, parallel_poly_from_expr, Poly
from sympy.polys.groebnertools import sdp_from_dict, sdp_rem, sdp_sort
from sympy.polys.monomialtools import monomial_key, monomial_div
from sympy.utilities import flatten
from sympy import symbols, solve

def is_zero_dimensional(G, *gens, **args):
    """
    Checks if the ideal generated by G is zero-dimensional (or,
    equivalently, if the number of solutions of the system G is
    finite).
    In order to always obtain a correct result, G has to be a
    Groebner basis. However, if G is not a Groebner basis and `True`
    is returned, the ideal is zero-dimensional.

    For an ideal to be zero-dimensional, for every variable some
    power has to be the leading monomial of an element of G.

    >>> from sympy import symbols
    >>> from sympy.polys.fglm import is_zero_dimensional
    >>> from sympy.polys import groebner
    >>> x, y, z = symbols('x, y, z')
    >>> F = [x**3 + x + 1, y**2 + 1, z - (x**2 + y)]
    >>> is_zero_dimensional(F, z, x, y, order='lex')  # lucky choice!
    True
    >>> is_zero_dimensional(F, x, y, z, order='lex')
    False
    >>> G = groebner(F, x, y, z, order='grlex')
    >>> is_zero_dimensional(G, x, y, z, order='grlex')
    True

    **References**
    Ideals, Varieties and Algorithms, David A. Cox, John B. Little, Donal O'Shea, 3rd edition, p. 234
    """
    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(G, *gens, **args)
    except PolificationError, exc:
        raise ComputationFailed('is_zero_dimensional', len(G), exc)

    u = len(flatten(gens)) - 1

    def single_var(m):
        """Returns `True` if only a single entry of the tuple m is not `0`. """
        n = 0
        for v in m:
            if v != 0:
                n += 1
        return n == 1

    # select leading monomials that are powers of a single variable
    leading_monomials = [g.LM(opt.order) for g in polys if single_var(g.LM(opt.order)) == True]

    exponents = [0] * (u + 1)

    for m in leading_monomials:
        exponents = map(lambda (e, f): e + f, zip(exponents, m))

    product = 1
    for e in exponents:
        product *= e

    return product != 0  #, product


def _normalform(f, G, gens, opt):
    polys = []

    for poly in [f] + G:
        polys.append(sdp_from_dict(poly.rep.to_dict(), monomial_key(opt.order)))

    #print(polys[0])
    #print(polys[1:])
    # FIXME: at some point the following causes an infinite loop, which is weird because
    # if I print the polynomials that cause a problem and do it in isympy, it works without problems.
    r = sdp_rem(polys[0], polys[1:], len(gens) - 1, monomial_key(opt.order), opt.domain)
    #print(r)
    r = Poly._from_dict(dict(r), opt)

    #print(polys[0])
    #for p in polys[1:]:
    #    print("               ", p)
   
    return r

def fglm(F, to_order, *gens, **args):
    """
    FGLM
    """
    if is_zero_dimensional(F, *gens, **args) == False:
        raise ComputationFailed("Ideal generated by G not zero-dimensional")

    options.allowed_flags(args, ['polys'])

    try:
        polys, opt = parallel_poly_from_expr(F, *gens, **args)
    except PolificationFailed, exc:
        raise ComputationFailed('fglm', len(F), exc)

    domain = opt.domain

    if domain.has_assoc_Field:
        opt.domain = domain.get_field()
    else:
        raise DomainError("can't convert Groebner basis over %s" % domain)

    gens = flatten(gens)

    L = []
    S = []
    V = []
    G = []
    t = Poly(1, gens)

    while True:
        #print(len(L), len(G))
        #print(t)
        v = _normalform(t, polys, gens, opt)
        #print(t, "-->", v)
        
        _lambda = symbols("l:%d" % len(V))
        p = v - sum([Poly(_lambda[i], gens) * V[i] for i in xrange(len(V))])
        
        coeffs = p.coeffs()
        
        if coeffs == [1]:
            sol = None
        else:
            sol = solve(coeffs, _lambda)

        
        if sol:
            p = t - sum([Poly(_lambda[i], gens) * S[i] for i in xrange(len(V))])
            if len(_lambda) == 1:
                p = p.subs(_lambda[0], sol[0])
            else:
                p = p.subs(sol)
            G.append(Poly(p, gens))
        else:
            S.append(t)
            V.append(v)

            L.extend([t * Poly(var, gens) for var in gens])

            indices = []
            for i, l in enumerate(L):
                if any([monomial_div(l.LM(to_order), g.LM(to_order)) is not None for g in G]):
                    indices.append(i)
            for i in reversed(indices):
                del L[i]
           
            L.sort(key=lambda f: monomial_key(to_order)(f.LM(to_order))) # from, to?

        if L == []:
            if not domain.has_Field:
                G = [ g.clear_denoms(convert=True)[1] for g in G ]

            opt.order = to_order
            R = reduced(G, gens, opt)
            R.sort(key=lambda f: monomial_key(to_order)(f.LM(to_order)), reverse=True)
            if not opt.polys:
                return [g.as_expr() for g in R]
            else:
                return R

        t = L[0]
        del L[0]

def reduced(G, gens, opt):
    F = G
    H = []

    while F:
        f0 = F.pop()

        if not any([monomial_div(f0.LM(opt.order), f.LM(opt.order)) is not None for f in F + H]):
            H.append(f0)

    R = []

    for i, g in enumerate(H):
        g = _normalform(g, H[:i] + H[i + 1:], gens, opt)
        if not g.is_zero:
            R.append(g)

    return R
